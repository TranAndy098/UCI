<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ds_messenger API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ds_messenger</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import socket
import ds_protocol
from typing import TextIO
import asyncio, time, json
from collections import namedtuple

port = 3021

class MessengerException(Exception):
    &#34;&#34;&#34;
    An exception that is raised when the message fails to send to the server/recipient.
    &#34;&#34;&#34;
    pass


class ConnectionException(Exception):
    &#34;&#34;&#34;
    An exception that is raised when a connection can not be established.
    &#34;&#34;&#34;
    pass


class DSConnection:
    &#34;&#34;&#34;
    A class that is used to store the connection socket, send, and recieve informaiton, for the user to use at a future time.
    Also used to reduce redundancy in the send, write, and retrieve functions.
    &#34;&#34;&#34;
    connection: socket = None
    send: TextIO = None
    recv: TextIO = None


class DirectMessage:
    &#34;&#34;&#34;
    A class that is used to store the recipient, message, and time data for the program to use it through reference.
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;
        Initliazes the class to all the outside program or class to use the variables recipient, message, and timestamp to store informaiton.
        &#34;&#34;&#34;
        self.recipient = None
        self.message = None
        self.timestamp = None


class DirectMessenger:
    &#34;&#34;&#34;
    A class that is used to handle all of the sending and retrieving of data, that a client program or the GUI would need to preform.
    &#34;&#34;&#34;
    def __init__(self, dsuserver=None, username=None, password=None):
        &#34;&#34;&#34;
        Initliazes the class by assigning the dsuserver, username, and password to the classes variable set to be store and refrenced in other functions.
        Self.token is None becasue it will be assigned with the token from the server when connected.
        &#34;&#34;&#34;
        self.token = None
        self.dsuserver = dsuserver
        self.username = username
        self.password = password


    def connection(self, server:str, port:int):
        &#34;&#34;&#34;
        Establishes a connection to the server so messages can be sent.
        If unable to, will return None so functions will stop and inform the user.
        &#34;&#34;&#34;
        try:
            ds_conn = DSConnection()
            ds_conn.connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            ds_conn.connection.connect((server,port))
            ds_conn.send = ds_conn.connection.makefile(&#39;w&#39;)
            ds_conn.recv = ds_conn.connection.makefile(&#39;r&#39;)
            return ds_conn
        except:
            return None


    def join(self, ds_conn:DSConnection, username:str, password:str) -&gt; str:
      &#34;&#34;&#34;
      Takes in the parameter and uses the ds_protocol to make the join message.
      Takes the join message and puts it into the write function to be written to the server.
      &#34;&#34;&#34;
      j_msg = ds_protocol.joinmsg(username, password)
      resp = self.write(ds_conn, j_msg)
      return ds_protocol.extract_token(resp)


    def write(self, ds_conn:DSConnection, message:str):
        &#34;&#34;&#34;
        Takes in the message to be sent to the server.
        Will write it then flush it to the server.
        Will return the response the server provides, to be further analyze.
        &#34;&#34;&#34;
        ds_conn.send.write(message + &#39;\r\n&#39;)
        ds_conn.send.flush()
        resp = ds_conn.recv.readline()
        return resp

    def send(self, message:str, recipient:str) -&gt; bool:
        &#34;&#34;&#34;
        This function will use its fellow classes and functions to send a message to a recipient.
        Will store the information of the message and recipient.
        Establish a connection to the server.
        Will then send the message to the recipient that is passed in.
        If unable to connect or send, an exception will be raised depending on which kind it is.
        If successful, will return True, else it will return False.
        &#34;&#34;&#34;
        connect = self.connection(self.dsuserver, port)
        dm = DirectMessage()
        dm.recipient = recipient
        dm.message = message
        dm.timestamp = str(time.time())
        try:
            if connect == None:
                raise ConnectionException()
                return False
            else:
                self.token = self.join(connect, self.username, self.password)
                msg = ds_protocol.send_directmessage(self.token, dm.message, dm.recipient, dm.timestamp)
                resp = self.write(connect, msg)
                resps = ds_protocol.extract_response_typ(resp)
                return resps
            if resps == &#39;ok&#39;:
                print(&#39;Direct Message Sent&#39;)
                return True
            else:
                raise MessengerException()
                return False
        
        except ConnectionException:
            print(&#34;Cannot Connect. Please Check Connection&#34;)
            return False
        
        except MessengerException:
            print(&#39;Direct Message Unable to be Sent&#39;)
            return False


    def retrieve_new(self) -&gt; list:
        &#34;&#34;&#34;
        Will connect to the server.
        Will retrieve of new messages that were sent to the user.
        Returns a list of DirectMessage objects containing new messages.
        Returns none if something did not connect or can not be retrieved.
        &#34;&#34;&#34;
        connect = self.connection(self.dsuserver, port)
        try:
            if connect == None:
                raise ConnectionException()
                return None
            else:
                try:
                    self.token = self.join(connect, self.username, self.password)
                    if self.token != None:
                        new_msg = ds_protocol.request_messages(self.token,&#39;new&#39;)
                        resp = self.write(connect, new_msg)
                        resps = ds_protocol.extract_response_typ(resp)
                        messages = ds_protocol.extract_json(resp)
                        return messages
                    else:
                        raise ConnectionException
                        return None
                except:
                    print(&#39;ERROR&#39;)
                    return None
        except ConnectionException:
            print(&#34;Connection Error&#34;)


    def retrieve_all(self) -&gt; list:
        &#34;&#34;&#34;
        Will connect to the server.
        Will retrieve of all messages that were sent to the user.
        Returns a list of DirectMessage objects containing all messages.
        Returns none if something did not connect or can not be retrieved.
        &#34;&#34;&#34;
        connect = self.connection(self.dsuserver, port)    
        try:
            if connect == None:
                raise ConnectionException()
                return None
            else:
                try:
                    self.token = self.join(connect, self.username, self.password)
                    if self.token != None:
                        new_msg = ds_protocol.request_messages(self.token,&#39;all&#39;)
                        resp = self.write(connect, new_msg)
                        resps = ds_protocol.extract_response_typ(resp)
                        messages = ds_protocol.extract_json(resp)
                        return messages
                    else:
                        raise ConnectionException
                        return None
                except:
                    print(&#39;ERROR&#39;)
                    return None
        except ConnectionException:
            print(&#34;Connection Error&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ds_messenger.ConnectionException"><code class="flex name class">
<span>class <span class="ident">ConnectionException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An exception that is raised when a connection can not be established.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConnectionException(Exception):
    &#34;&#34;&#34;
    An exception that is raised when a connection can not be established.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="ds_messenger.DSConnection"><code class="flex name class">
<span>class <span class="ident">DSConnection</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class that is used to store the connection socket, send, and recieve informaiton, for the user to use at a future time.
Also used to reduce redundancy in the send, write, and retrieve functions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DSConnection:
    &#34;&#34;&#34;
    A class that is used to store the connection socket, send, and recieve informaiton, for the user to use at a future time.
    Also used to reduce redundancy in the send, write, and retrieve functions.
    &#34;&#34;&#34;
    connection: socket = None
    send: TextIO = None
    recv: TextIO = None</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="ds_messenger.DSConnection.connection"><code class="name">var <span class="ident">connection</span> : <module 'socket' from '/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/socket.py'></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ds_messenger.DSConnection.recv"><code class="name">var <span class="ident">recv</span> : <class 'TextIO'></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ds_messenger.DSConnection.send"><code class="name">var <span class="ident">send</span> : <class 'TextIO'></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="ds_messenger.DirectMessage"><code class="flex name class">
<span>class <span class="ident">DirectMessage</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class that is used to store the recipient, message, and time data for the program to use it through reference.</p>
<p>Initliazes the class to all the outside program or class to use the variables recipient, message, and timestamp to store informaiton.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DirectMessage:
    &#34;&#34;&#34;
    A class that is used to store the recipient, message, and time data for the program to use it through reference.
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;
        Initliazes the class to all the outside program or class to use the variables recipient, message, and timestamp to store informaiton.
        &#34;&#34;&#34;
        self.recipient = None
        self.message = None
        self.timestamp = None</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessenger"><code class="flex name class">
<span>class <span class="ident">DirectMessenger</span></span>
<span>(</span><span>dsuserver=None, username=None, password=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that is used to handle all of the sending and retrieving of data, that a client program or the GUI would need to preform.</p>
<p>Initliazes the class by assigning the dsuserver, username, and password to the classes variable set to be store and refrenced in other functions.
Self.token is None becasue it will be assigned with the token from the server when connected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DirectMessenger:
    &#34;&#34;&#34;
    A class that is used to handle all of the sending and retrieving of data, that a client program or the GUI would need to preform.
    &#34;&#34;&#34;
    def __init__(self, dsuserver=None, username=None, password=None):
        &#34;&#34;&#34;
        Initliazes the class by assigning the dsuserver, username, and password to the classes variable set to be store and refrenced in other functions.
        Self.token is None becasue it will be assigned with the token from the server when connected.
        &#34;&#34;&#34;
        self.token = None
        self.dsuserver = dsuserver
        self.username = username
        self.password = password


    def connection(self, server:str, port:int):
        &#34;&#34;&#34;
        Establishes a connection to the server so messages can be sent.
        If unable to, will return None so functions will stop and inform the user.
        &#34;&#34;&#34;
        try:
            ds_conn = DSConnection()
            ds_conn.connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            ds_conn.connection.connect((server,port))
            ds_conn.send = ds_conn.connection.makefile(&#39;w&#39;)
            ds_conn.recv = ds_conn.connection.makefile(&#39;r&#39;)
            return ds_conn
        except:
            return None


    def join(self, ds_conn:DSConnection, username:str, password:str) -&gt; str:
      &#34;&#34;&#34;
      Takes in the parameter and uses the ds_protocol to make the join message.
      Takes the join message and puts it into the write function to be written to the server.
      &#34;&#34;&#34;
      j_msg = ds_protocol.joinmsg(username, password)
      resp = self.write(ds_conn, j_msg)
      return ds_protocol.extract_token(resp)


    def write(self, ds_conn:DSConnection, message:str):
        &#34;&#34;&#34;
        Takes in the message to be sent to the server.
        Will write it then flush it to the server.
        Will return the response the server provides, to be further analyze.
        &#34;&#34;&#34;
        ds_conn.send.write(message + &#39;\r\n&#39;)
        ds_conn.send.flush()
        resp = ds_conn.recv.readline()
        return resp

    def send(self, message:str, recipient:str) -&gt; bool:
        &#34;&#34;&#34;
        This function will use its fellow classes and functions to send a message to a recipient.
        Will store the information of the message and recipient.
        Establish a connection to the server.
        Will then send the message to the recipient that is passed in.
        If unable to connect or send, an exception will be raised depending on which kind it is.
        If successful, will return True, else it will return False.
        &#34;&#34;&#34;
        connect = self.connection(self.dsuserver, port)
        dm = DirectMessage()
        dm.recipient = recipient
        dm.message = message
        dm.timestamp = str(time.time())
        try:
            if connect == None:
                raise ConnectionException()
                return False
            else:
                self.token = self.join(connect, self.username, self.password)
                msg = ds_protocol.send_directmessage(self.token, dm.message, dm.recipient, dm.timestamp)
                resp = self.write(connect, msg)
                resps = ds_protocol.extract_response_typ(resp)
                return resps
            if resps == &#39;ok&#39;:
                print(&#39;Direct Message Sent&#39;)
                return True
            else:
                raise MessengerException()
                return False
        
        except ConnectionException:
            print(&#34;Cannot Connect. Please Check Connection&#34;)
            return False
        
        except MessengerException:
            print(&#39;Direct Message Unable to be Sent&#39;)
            return False


    def retrieve_new(self) -&gt; list:
        &#34;&#34;&#34;
        Will connect to the server.
        Will retrieve of new messages that were sent to the user.
        Returns a list of DirectMessage objects containing new messages.
        Returns none if something did not connect or can not be retrieved.
        &#34;&#34;&#34;
        connect = self.connection(self.dsuserver, port)
        try:
            if connect == None:
                raise ConnectionException()
                return None
            else:
                try:
                    self.token = self.join(connect, self.username, self.password)
                    if self.token != None:
                        new_msg = ds_protocol.request_messages(self.token,&#39;new&#39;)
                        resp = self.write(connect, new_msg)
                        resps = ds_protocol.extract_response_typ(resp)
                        messages = ds_protocol.extract_json(resp)
                        return messages
                    else:
                        raise ConnectionException
                        return None
                except:
                    print(&#39;ERROR&#39;)
                    return None
        except ConnectionException:
            print(&#34;Connection Error&#34;)


    def retrieve_all(self) -&gt; list:
        &#34;&#34;&#34;
        Will connect to the server.
        Will retrieve of all messages that were sent to the user.
        Returns a list of DirectMessage objects containing all messages.
        Returns none if something did not connect or can not be retrieved.
        &#34;&#34;&#34;
        connect = self.connection(self.dsuserver, port)    
        try:
            if connect == None:
                raise ConnectionException()
                return None
            else:
                try:
                    self.token = self.join(connect, self.username, self.password)
                    if self.token != None:
                        new_msg = ds_protocol.request_messages(self.token,&#39;all&#39;)
                        resp = self.write(connect, new_msg)
                        resps = ds_protocol.extract_response_typ(resp)
                        messages = ds_protocol.extract_json(resp)
                        return messages
                    else:
                        raise ConnectionException
                        return None
                except:
                    print(&#39;ERROR&#39;)
                    return None
        except ConnectionException:
            print(&#34;Connection Error&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ds_messenger.DirectMessenger.connection"><code class="name flex">
<span>def <span class="ident">connection</span></span>(<span>self, server: str, port: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Establishes a connection to the server so messages can be sent.
If unable to, will return None so functions will stop and inform the user.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connection(self, server:str, port:int):
    &#34;&#34;&#34;
    Establishes a connection to the server so messages can be sent.
    If unable to, will return None so functions will stop and inform the user.
    &#34;&#34;&#34;
    try:
        ds_conn = DSConnection()
        ds_conn.connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        ds_conn.connection.connect((server,port))
        ds_conn.send = ds_conn.connection.makefile(&#39;w&#39;)
        ds_conn.recv = ds_conn.connection.makefile(&#39;r&#39;)
        return ds_conn
    except:
        return None</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessenger.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>self, ds_conn: <a title="ds_messenger.DSConnection" href="#ds_messenger.DSConnection">DSConnection</a>, username: str, password: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Takes in the parameter and uses the ds_protocol to make the join message.
Takes the join message and puts it into the write function to be written to the server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join(self, ds_conn:DSConnection, username:str, password:str) -&gt; str:
  &#34;&#34;&#34;
  Takes in the parameter and uses the ds_protocol to make the join message.
  Takes the join message and puts it into the write function to be written to the server.
  &#34;&#34;&#34;
  j_msg = ds_protocol.joinmsg(username, password)
  resp = self.write(ds_conn, j_msg)
  return ds_protocol.extract_token(resp)</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessenger.retrieve_all"><code class="name flex">
<span>def <span class="ident">retrieve_all</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Will connect to the server.
Will retrieve of all messages that were sent to the user.
Returns a list of DirectMessage objects containing all messages.
Returns none if something did not connect or can not be retrieved.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_all(self) -&gt; list:
    &#34;&#34;&#34;
    Will connect to the server.
    Will retrieve of all messages that were sent to the user.
    Returns a list of DirectMessage objects containing all messages.
    Returns none if something did not connect or can not be retrieved.
    &#34;&#34;&#34;
    connect = self.connection(self.dsuserver, port)    
    try:
        if connect == None:
            raise ConnectionException()
            return None
        else:
            try:
                self.token = self.join(connect, self.username, self.password)
                if self.token != None:
                    new_msg = ds_protocol.request_messages(self.token,&#39;all&#39;)
                    resp = self.write(connect, new_msg)
                    resps = ds_protocol.extract_response_typ(resp)
                    messages = ds_protocol.extract_json(resp)
                    return messages
                else:
                    raise ConnectionException
                    return None
            except:
                print(&#39;ERROR&#39;)
                return None
    except ConnectionException:
        print(&#34;Connection Error&#34;)</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessenger.retrieve_new"><code class="name flex">
<span>def <span class="ident">retrieve_new</span></span>(<span>self) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Will connect to the server.
Will retrieve of new messages that were sent to the user.
Returns a list of DirectMessage objects containing new messages.
Returns none if something did not connect or can not be retrieved.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_new(self) -&gt; list:
    &#34;&#34;&#34;
    Will connect to the server.
    Will retrieve of new messages that were sent to the user.
    Returns a list of DirectMessage objects containing new messages.
    Returns none if something did not connect or can not be retrieved.
    &#34;&#34;&#34;
    connect = self.connection(self.dsuserver, port)
    try:
        if connect == None:
            raise ConnectionException()
            return None
        else:
            try:
                self.token = self.join(connect, self.username, self.password)
                if self.token != None:
                    new_msg = ds_protocol.request_messages(self.token,&#39;new&#39;)
                    resp = self.write(connect, new_msg)
                    resps = ds_protocol.extract_response_typ(resp)
                    messages = ds_protocol.extract_json(resp)
                    return messages
                else:
                    raise ConnectionException
                    return None
            except:
                print(&#39;ERROR&#39;)
                return None
    except ConnectionException:
        print(&#34;Connection Error&#34;)</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessenger.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, message: str, recipient: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>This function will use its fellow classes and functions to send a message to a recipient.
Will store the information of the message and recipient.
Establish a connection to the server.
Will then send the message to the recipient that is passed in.
If unable to connect or send, an exception will be raised depending on which kind it is.
If successful, will return True, else it will return False.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send(self, message:str, recipient:str) -&gt; bool:
    &#34;&#34;&#34;
    This function will use its fellow classes and functions to send a message to a recipient.
    Will store the information of the message and recipient.
    Establish a connection to the server.
    Will then send the message to the recipient that is passed in.
    If unable to connect or send, an exception will be raised depending on which kind it is.
    If successful, will return True, else it will return False.
    &#34;&#34;&#34;
    connect = self.connection(self.dsuserver, port)
    dm = DirectMessage()
    dm.recipient = recipient
    dm.message = message
    dm.timestamp = str(time.time())
    try:
        if connect == None:
            raise ConnectionException()
            return False
        else:
            self.token = self.join(connect, self.username, self.password)
            msg = ds_protocol.send_directmessage(self.token, dm.message, dm.recipient, dm.timestamp)
            resp = self.write(connect, msg)
            resps = ds_protocol.extract_response_typ(resp)
            return resps
        if resps == &#39;ok&#39;:
            print(&#39;Direct Message Sent&#39;)
            return True
        else:
            raise MessengerException()
            return False
    
    except ConnectionException:
        print(&#34;Cannot Connect. Please Check Connection&#34;)
        return False
    
    except MessengerException:
        print(&#39;Direct Message Unable to be Sent&#39;)
        return False</code></pre>
</details>
</dd>
<dt id="ds_messenger.DirectMessenger.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>self, ds_conn: <a title="ds_messenger.DSConnection" href="#ds_messenger.DSConnection">DSConnection</a>, message: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes in the message to be sent to the server.
Will write it then flush it to the server.
Will return the response the server provides, to be further analyze.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write(self, ds_conn:DSConnection, message:str):
    &#34;&#34;&#34;
    Takes in the message to be sent to the server.
    Will write it then flush it to the server.
    Will return the response the server provides, to be further analyze.
    &#34;&#34;&#34;
    ds_conn.send.write(message + &#39;\r\n&#39;)
    ds_conn.send.flush()
    resp = ds_conn.recv.readline()
    return resp</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ds_messenger.MessengerException"><code class="flex name class">
<span>class <span class="ident">MessengerException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>An exception that is raised when the message fails to send to the server/recipient.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MessengerException(Exception):
    &#34;&#34;&#34;
    An exception that is raised when the message fails to send to the server/recipient.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ds_messenger.ConnectionException" href="#ds_messenger.ConnectionException">ConnectionException</a></code></h4>
</li>
<li>
<h4><code><a title="ds_messenger.DSConnection" href="#ds_messenger.DSConnection">DSConnection</a></code></h4>
<ul class="">
<li><code><a title="ds_messenger.DSConnection.connection" href="#ds_messenger.DSConnection.connection">connection</a></code></li>
<li><code><a title="ds_messenger.DSConnection.recv" href="#ds_messenger.DSConnection.recv">recv</a></code></li>
<li><code><a title="ds_messenger.DSConnection.send" href="#ds_messenger.DSConnection.send">send</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ds_messenger.DirectMessage" href="#ds_messenger.DirectMessage">DirectMessage</a></code></h4>
</li>
<li>
<h4><code><a title="ds_messenger.DirectMessenger" href="#ds_messenger.DirectMessenger">DirectMessenger</a></code></h4>
<ul class="two-column">
<li><code><a title="ds_messenger.DirectMessenger.connection" href="#ds_messenger.DirectMessenger.connection">connection</a></code></li>
<li><code><a title="ds_messenger.DirectMessenger.join" href="#ds_messenger.DirectMessenger.join">join</a></code></li>
<li><code><a title="ds_messenger.DirectMessenger.retrieve_all" href="#ds_messenger.DirectMessenger.retrieve_all">retrieve_all</a></code></li>
<li><code><a title="ds_messenger.DirectMessenger.retrieve_new" href="#ds_messenger.DirectMessenger.retrieve_new">retrieve_new</a></code></li>
<li><code><a title="ds_messenger.DirectMessenger.send" href="#ds_messenger.DirectMessenger.send">send</a></code></li>
<li><code><a title="ds_messenger.DirectMessenger.write" href="#ds_messenger.DirectMessenger.write">write</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ds_messenger.MessengerException" href="#ds_messenger.MessengerException">MessengerException</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>